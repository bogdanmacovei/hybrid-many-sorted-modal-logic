abbrev Agent := String 

inductive Message (œÉ : Nat) where
| empty : Message œÉ
| text : String ‚Üí Message œÉ
| agent : Agent ‚Üí Message œÉ
| symmetricKey : Agent ‚Üí Agent ‚Üí Message œÉ ‚Üí Message œÉ
| publicKey : Agent ‚Üí Message œÉ
| secretKey : Agent ‚Üí Message œÉ
| encrypt : Message œÉ ‚Üí Message œÉ ‚Üí Message œÉ
| concat : Message œÉ ‚Üí Message œÉ ‚Üí Message œÉ
deriving Repr, BEq

notation " #Œº " i => Message.empty i
notation " # " t " # " => Message.text t
notation " pk( " i " ) " => Message.publicKey i
notation " sk( " i " ) " => Message.secretKey i
notation " ‚¶É| " m " |‚¶Ñ " k  => Message.encrypt m k
notation " ag( " i " ) " => Message.agent i 
notation " text( " t " ) " => Message.text t 
notation m‚ÇÅ " ‚Äñ " m‚ÇÇ => Message.concat m‚ÇÅ m‚ÇÇ

inductive Action (œÉ : Nat) where 
| send : Agent ‚Üí Agent ‚Üí Message œÉ ‚Üí Action œÉ 
| recv : Agent ‚Üí Message œÉ ‚Üí Action œÉ 
| comp : Action œÉ ‚Üí Action œÉ ‚Üí Action œÉ 
| reun : Action œÉ ‚Üí Action œÉ ‚Üí Action œÉ 
deriving Repr, BEq 

notation " send " i ", " j " ( " Œº " ) " => Action.send i j Œº 
notation " recv " i " ( " Œº " ) " => Action.recv i Œº 
notation Œ±‚ÇÅ " ; " Œ±‚ÇÇ => Action.comp Œ±‚ÇÅ Œ±‚ÇÇ 
notation Œ±‚ÇÅ " ‚à™‚à™ " Œ±‚ÇÇ => Action.reun Œ±‚ÇÅ Œ±‚ÇÇ 

inductive State (œÉ : Nat) where 
| explicit : Agent ‚Üí Message œÉ ‚Üí State œÉ 
| add : State œÉ ‚Üí State œÉ ‚Üí State œÉ
deriving Repr, BEq 

notation a " ‚ñ∑ " Œº => State.explicit a Œº 
notation Œ≥‚ÇÅ " ‚äî " Œ≥‚ÇÇ => State.add Œ≥‚ÇÅ Œ≥‚ÇÇ 

inductive Formula (œÉ : Nat) where 
| atom : Fin œÉ ‚Üí Formula œÉ
| true : Formula œÉ 
| neg : Formula œÉ ‚Üí Formula œÉ 
| imp : Formula œÉ ‚Üí Formula œÉ ‚Üí Formula œÉ 
| believe : Agent ‚Üí Formula œÉ ‚Üí Formula œÉ 
| explicit : Agent ‚Üí Message œÉ ‚Üí Formula œÉ
| state2form : State œÉ ‚Üí Formula œÉ 
| state : Formula œÉ ‚Üí Formula œÉ 
| action : Action œÉ ‚Üí Formula œÉ ‚Üí Formula œÉ 
deriving Repr, BEq 

notation " #œï " i => Formula.atom i
notation " ‚ä§ " => Formula.true 
notation " ~ " œÜ => Formula.neg œÜ
notation " ‚ä• " => (~‚ä§)
notation œÜ " ‚ü∂ " œà => Formula.imp œÜ œà
notation œÜ " ‚ãÅ " œà => ((~œÜ) ‚ü∂ œà)
notation œÜ " ‚ãÄ " œà => ~((~œÜ) ‚ãÅ (~œà))
notation " ùîπ " i " , " œÜ => Formula.believe i œÜ
notation " ùïÇ " i " , " œÜ => (ùîπ i, œÜ) ‚ãÄ œÜ 
notation " ùïè " i " , " m => Formula.explicit i m
notation " Œπ " Œ≥ => Formula.state2form Œ≥ 
notation " ‚ü® " Œ≥ " ‚ü© " => Formula.state Œ≥ 
notation " [ " Œ± " ] " œÜ => Formula.action Œ± œÜ 

inductive Proof {œÉ : Nat} : Context œÉ ‚Üí Formula œÉ ‚Üí Prop  
-- Hilbert basic 
| ax { Œì } { p : Formula œÉ } (h : Œì.Mem p) : Proof Œì p 
| pl‚ÇÅ { Œì } { p q : Formula œÉ } : Proof Œì (p ‚ü∂ (q ‚ü∂ p))
| pl‚ÇÇ { Œì } { p q r : Formula œÉ } : Proof Œì $ (p ‚ü∂ (q ‚ü∂ r)) ‚ü∂ ((p ‚ü∂ q) ‚ü∂ (p ‚ü∂ r)) 
| pl‚ÇÉ { Œì } { p q : Formula œÉ } : Proof Œì $ ((~p) ‚ü∂ ~q) ‚ü∂ (q ‚ü∂ p)
-- K axiom for programs
| KŒ± { Œì } { œÜ œà : Formula œÉ } { Œ± : Action œÉ } : Proof Œì $ ([Œ±](œÜ ‚ü∂ œà)) ‚ü∂ (([Œ±]œÜ) ‚ü∂ ([Œ±]œà))
-- Belief 
| Kùîπ { Œì } { œÜ œà : Formula œÉ } { a : Agent } : Proof Œì $ (ùîπ a, (œÜ ‚ü∂ œà)) ‚ü∂ ((ùîπ a, œÜ) ‚ü∂ (ùîπ a, œà))
| D { Œì } { œÜ : Formula œÉ } {a : Agent} : Proof Œì $ (ùîπ a, œÜ) ‚ü∂ ~(ùîπ a, (~œÜ))
| _4 { Œì } { œÜ : Formula œÉ } {a : Agent} : Proof Œì $ (ùîπ a, œÜ) ‚ü∂ (ùîπ a, (ùîπ a, œÜ)) 
| _5 { Œì } { œÜ : Formula œÉ } {a : Agent} : Proof Œì $ (~(ùîπ a, œÜ)) ‚ü∂ (ùîπ a, (~(ùîπ a, œÜ))) 
-- Deduction rules 
| MP { Œì } { p q : Formula œÉ } (hpq : Proof Œì $ p ‚ü∂ q) (hp : Proof Œì p) : Proof Œì q
| NECùîπ { Œì } { œÜ : Formula œÉ } { a : Agent } (hœÜ : Proof Œì œÜ) : Proof Œì $ ùîπ a, œÜ 
| NECŒ± { Œì } { œÜ : Formula œÉ } { Œ± : Action œÉ } (hœÜ : Proof Œì œÜ) : Proof Œì $ [Œ±]œÜ 
-- Actions 
| Acomp_left { Œì } {Œ±‚ÇÅ Œ±‚ÇÇ : Action œÉ } { œÜ : Formula œÉ } : Proof Œì $ ([Œ±‚ÇÅ ; Œ±‚ÇÇ]œÜ) ‚ü∂ [Œ±‚ÇÅ]([Œ±‚ÇÇ]œÜ)
| Acopm_right { Œì } {Œ±‚ÇÅ Œ±‚ÇÇ : Action œÉ } { œÜ : Formula œÉ } : Proof Œì $ [Œ±‚ÇÅ]([Œ±‚ÇÇ]œÜ) ‚ü∂ ([Œ±‚ÇÅ ; Œ±‚ÇÇ]œÜ)
-- States 
| St‚ÇÅ_left { Œì } { Œ≥‚ÇÅ Œ≥‚ÇÇ : State œÉ } { a : Agent } { m : Message œÉ } : Proof Œì $ (Œπ (Œ≥‚ÇÅ ‚äî ((a ‚ñ∑ m) ‚äî Œ≥‚ÇÇ))) ‚ü∂ Œπ ((a ‚ñ∑ m) ‚äî (Œ≥‚ÇÅ ‚äî Œ≥‚ÇÇ))
| St‚ÇÅ_right { Œì } { Œ≥‚ÇÅ Œ≥‚ÇÇ : State œÉ } { a : Agent } { m : Message œÉ } : Proof Œì $ (Œπ ((a ‚ñ∑ m) ‚äî (Œ≥‚ÇÅ ‚äî Œ≥‚ÇÇ))) ‚ü∂  Œπ (Œ≥‚ÇÅ ‚äî ((a ‚ñ∑ m) ‚äî Œ≥‚ÇÇ))
| St‚ÇÇ_left { Œì } { Œ≥ : State œÉ } { a : Agent } { m : Message œÉ } : Proof Œì $ (Œπ ((a ‚ñ∑ m) ‚äî ((a ‚ñ∑ m) ‚äî Œ≥))) ‚ü∂  Œπ ((a ‚ñ∑ m) ‚äî Œ≥)
| St‚ÇÇ_right { Œì } { Œ≥ : State œÉ } { a : Agent } { m : Message œÉ } : Proof Œì $ (Œπ ((a ‚ñ∑ m) ‚äî Œ≥)) ‚ü∂ Œπ ((a ‚ñ∑ m) ‚äî ((a ‚ñ∑ m) ‚äî Œ≥))
| St‚ÇÉ { Œì } { Œ≥ : State œÉ } { a : Agent } { m : Message œÉ } : Proof Œì $ (Œπ ((a ‚ñ∑ m) ‚äî Œ≥)) ‚ü∂ ùïè a, m
-- theorems
| St‚ÇÅ_left' { Œì } { Œ≥‚ÇÅ Œ≥‚ÇÇ : State œÉ } { a : Agent } { m : Message œÉ } : Proof Œì $ ‚ü®Œπ (Œ≥‚ÇÅ ‚äî ((a ‚ñ∑ m) ‚äî Œ≥‚ÇÇ))‚ü© ‚ü∂  ‚ü®Œπ ((a ‚ñ∑ m) ‚äî (Œ≥‚ÇÅ ‚äî Œ≥‚ÇÇ))‚ü©
| St‚ÇÅ_right' { Œì } { Œ≥‚ÇÅ Œ≥‚ÇÇ : State œÉ } { a : Agent } { m : Message œÉ } : Proof Œì $ ‚ü®Œπ ((a ‚ñ∑ m) ‚äî (Œ≥‚ÇÅ ‚äî Œ≥‚ÇÇ))‚ü© ‚ü∂  ‚ü®Œπ (Œ≥‚ÇÅ ‚äî ((a ‚ñ∑ m) ‚äî Œ≥‚ÇÇ))‚ü©
| St‚ÇÇ_left' { Œì } { Œ≥ : State œÉ } { a : Agent } { m : Message œÉ } : Proof Œì $ ‚ü®Œπ ((a ‚ñ∑ m) ‚äî ((a ‚ñ∑ m) ‚äî Œ≥))‚ü© ‚ü∂  ‚ü®Œπ ((a ‚ñ∑ m) ‚äî Œ≥)‚ü©
| St‚ÇÇ_right' { Œì } { Œ≥ : State œÉ } { a : Agent } { m : Message œÉ } : Proof Œì $ ‚ü®Œπ ((a ‚ñ∑ m) ‚äî Œ≥)‚ü© ‚ü∂ ‚ü®Œπ ((a ‚ñ∑ m) ‚äî ((a ‚ñ∑ m) ‚äî Œ≥))‚ü©
| St‚ÇÉ' { Œì } { Œ≥ : State œÉ } { a : Agent } { m : Message œÉ } : Proof Œì $ ‚ü®Œπ ((a ‚ñ∑ m) ‚äî Œ≥)‚ü© ‚ü∂ ‚ü®ùïè a, m‚ü©

notation Œì " ‚ä¢ " œÜ => Proof Œì œÜ 

/-
  **PROTOCOLS**
-/

open Formula 
open Proof 

inductive ProtocolProof { œÉ : Nat } : Context œÉ ‚Üí Formula œÉ ‚Üí Prop 
-- an extension of standard proofs  
| base { Œì } { œÜ } (proof : Proof Œì œÜ) : ProtocolProof Œì œÜ 
-- messages  
| X‚ÇÅ_left { Œì } { a : Agent } { m‚ÇÅ m‚ÇÇ : Message œÉ } : ProtocolProof Œì $ (ùïè a, (m‚ÇÅ.concat m‚ÇÇ)) ‚ü∂ ((ùïè a, m‚ÇÅ) ‚ãÄ (ùïè a, m‚ÇÇ))
| X‚ÇÅ_right { Œì } { a : Agent }{ m‚ÇÅ m‚ÇÇ : Message œÉ } : ProtocolProof Œì $ ((ùïè a, m‚ÇÅ) ‚ãÄ (ùïè a, m‚ÇÇ)) ‚ü∂ (ùïè a, (m‚ÇÅ.concat m‚ÇÇ))
| X‚ÇÇ_left { Œì } { a b : Agent } { k : Message œÉ } : ProtocolProof Œì $ (ùïè a, (Message.symmetricKey a b k)) ‚ü∂ (ùïè b, (Message.symmetricKey b a k))
| X‚ÇÇ_right { Œì } { a b : Agent } { k : Message œÉ } : ProtocolProof Œì $ (ùïè b, (Message.symmetricKey b a k)) ‚ü∂ (ùïè a, (Message.symmetricKey a b k))
| X‚ÇÉ { Œì } { a b : Agent } { m : Message œÉ } : ProtocolProof Œì $ ((ùïè a, ‚¶É|m|‚¶Ñ pk(b)) ‚ãÄ (ùïè a, sk(b))) ‚ü∂ (ùïè a, m)
| X‚ÇÑ { Œì } { a b : Agent } { m : Message œÉ } : ProtocolProof Œì $ ((ùïè a, ‚¶É|m|‚¶Ñ sk(b)) ‚ãÄ (ùïè a, pk(b))) ‚ü∂ (ùïè a, m)
| X‚ÇÖ { Œì } { a : Agent } { m‚ÇÅ m‚ÇÇ : Message œÉ } : ProtocolProof Œì $ ((ùïè a, m‚ÇÅ) ‚ãÄ (ùïè a, m‚ÇÇ)) ‚ü∂ ùïè a, ‚¶É|m‚ÇÅ|‚¶Ñm‚ÇÇ 
| X‚ÇÜ { Œì } { a b : Agent } { m k : Message œÉ } : ProtocolProof Œì $ ((ùïè a, ‚¶É|m|‚¶Ñ (Message.symmetricKey a b k)) ‚ãÄ (ùïè a, (Message.symmetricKey a b k))) ‚ü∂ (ùïè a, m)
| X‚Çá { Œì } { a : Agent } : ProtocolProof Œì $ (ùïè a, ag(a))
-- protocol general hypotheses
| H‚ÇÅ { Œì } { a b e : Agent } {m : Message œÉ } { Œ≥ : State œÉ } : ProtocolProof Œì $ ‚ü® Œπ ((a ‚ñ∑ m) ‚äî Œ≥) ‚ü© ‚ü∂ [send a,b(‚¶É| ag(a) ‚Äñ  m |‚¶Ñpk(b))]‚ü® Œπ ((e ‚ñ∑ m) ‚äî ((a ‚ñ∑ m) ‚äî Œ≥)) ‚ü© 
| H‚ÇÇ { Œì } { a b e : Agent } {m : Message œÉ } { Œ≥ : State œÉ } : ProtocolProof Œì $ ‚ü® Œπ ((e ‚ñ∑ m) ‚äî Œ≥) ‚ü© ‚ü∂ [recv a(‚¶É| ag(b) ‚Äñ m |‚¶Ñpk(a))]‚ü® Œπ ((a ‚ñ∑ m) ‚äî ((e ‚ñ∑ m) ‚äî Œ≥)) ‚ü©  

notation Œì " ‚ä¢‚Çö " œÜ => ProtocolProof Œì œÜ 

inductive OSSProof { œÉ : Nat } : Context œÉ ‚Üí Formula œÉ ‚Üí Prop 
| base { Œì } { œÜ } (proof : ProtocolProof Œì œÜ) : OSSProof Œì œÜ 
| S‚ÇÅ { Œì } {a b : Agent } { m : Message œÉ } { Œ≥ : State œÉ } : OSSProof Œì $ ‚ü® Œπ ((a ‚ñ∑ m) ‚äî Œ≥) ‚ü© ‚ü∂ [send a,b(‚¶É| ag(a) ‚Äñ  m |‚¶Ñpk(b))]ùîπ a, ‚ü® ùïè b, m ‚ü© 
| S‚ÇÅ' { Œì } {a b : Agent } { m : Message œÉ } { Œ≥ : State œÉ } { Œ± : Action œÉ } : OSSProof Œì $ ‚ü® Œπ ((a ‚ñ∑ m) ‚äî Œ≥) ‚ü© ‚ü∂ [(send a,b(‚¶É| ag(a) ‚Äñ  m |‚¶Ñpk(b))) ; Œ±]ùîπ a, ‚ü® ùïè b, m ‚ü© 
| S‚ÇÇ { Œì } { a b : Agent } { m : Message œÉ } { Œ≥ : State œÉ } : OSSProof Œì $ ‚ü® Œπ Œ≥ ‚ü© ‚ü∂ [recv b(‚¶É| ag(a) ‚Äñ  m |‚¶Ñpk(b))]ùîπ b, ‚ü® ùïè a, m ‚ü© 
| S‚ÇÇ' { Œì } { a b : Agent } { m : Message œÉ } { Œ± : Action œÉ } : OSSProof Œì $ [(recv b(‚¶É| ag(a) ‚Äñ  m |‚¶Ñpk(b))) ; Œ±]ùîπ b, ‚ü® ùïè a, m ‚ü© 
-- added to simplify 
| MP { Œì } { p q : Formula œÉ } (hpq : OSSProof Œì $ p ‚ü∂ q) (hp : OSSProof Œì p) : OSSProof Œì q
| NECŒ± { Œì } { œÜ : Formula œÉ } { Œ± : Action œÉ } (hœÜ : OSSProof Œì œÜ) : OSSProof Œì $ [Œ±]œÜ 

notation Œì " ‚ä¢‚Çí‚Çõ‚Çõ " œÜ => OSSProof Œì œÜ 


def Œ≥·µ¢‚Çô·µ¢‚Çú {œÉ : Nat} {i r : Agent} : State œÉ := (i ‚ñ∑ pk(i)) ‚äî (i ‚ñ∑ sk(i)) ‚äî (i ‚ñ∑ pk(i)) ‚äî (r ‚ñ∑ sk(r))

@[simp]
theorem pl_transitivity {œÉ : Nat} {p q r : Formula œÉ} { Œì : Context œÉ } : 
  (Œì ‚ä¢‚Çí‚Çõ‚Çõ (p ‚ü∂ q)) ‚Üí 
  (Œì ‚ä¢‚Çí‚Çõ‚Çõ (q ‚ü∂ r)) ‚Üí 
  (Œì ‚ä¢‚Çí‚Çõ‚Çõ (p ‚ü∂ r)) := by 
  intros hpq hqr
  have h‚ÇÅ : Œì ‚ä¢‚Çí‚Çõ‚Çõ (p ‚ü∂ q ‚ü∂ r) :=
    OSSProof.MP
      (OSSProof.base (ProtocolProof.base Proof.pl‚ÇÅ))
      hqr
  have h‚ÇÇ : Œì ‚ä¢‚Çí‚Çõ‚Çõ ((p ‚ü∂ q ‚ü∂ r) ‚ü∂ (p ‚ü∂ q) ‚ü∂ (p ‚ü∂ r)) :=
    OSSProof.base (ProtocolProof.base Proof.pl‚ÇÇ)
  have h‚ÇÉ : Œì ‚ä¢‚Çí‚Çõ‚Çõ ((p ‚ü∂ q) ‚ü∂ (p ‚ü∂ r)) :=
    OSSProof.MP h‚ÇÇ h‚ÇÅ
  exact OSSProof.MP h‚ÇÉ hpq

@[simp]
theorem dl_th_1 {œÉ : Nat} { p q r : Formula œÉ } { Œ± : Action œÉ } { Œì : Context œÉ } : 
  (Œì ‚ä¢‚Çí‚Çõ‚Çõ (p ‚ü∂ ([Œ±]q))) ‚Üí 
  (Œì ‚ä¢‚Çí‚Çõ‚Çõ (p ‚ü∂ ([Œ±]r))) ‚Üí 
  (Œì ‚ä¢‚Çí‚Çõ‚Çõ (p ‚ü∂ ([Œ±](q ‚ãÄ r)))) := by 
  admit 


@[simp]
theorem dl_th_2 {œÉ : Nat} { p q r : Formula œÉ } { Œ± Œ≤ : Action œÉ } { Œì : Context œÉ } : 
  (Œì ‚ä¢‚Çí‚Çõ‚Çõ (p ‚ü∂ ([Œ±][Œ≤](q ‚ãÄ r)))) ‚Üí 
  (Œì ‚ä¢‚Çí‚Çõ‚Çõ (p ‚ü∂ ([Œ±][Œ≤]r))) := by 
  intros h

  have prop_formula : Œì ‚ä¢ ((q ‚ãÄ r) ‚ü∂ r) := by
    admit 
  have nec_formula : Œì ‚ä¢ [Œ±][Œ≤]((q ‚ãÄ r) ‚ü∂ r) := Proof.NECŒ± (Proof.NECŒ± prop_formula)
  have nec_formula' : Œì ‚ä¢‚Çí‚Çõ‚Çõ [Œ±][Œ≤]((q ‚ãÄ r) ‚ü∂ r) :=
    OSSProof.base (ProtocolProof.base nec_formula)
  admit 

@[simp]
theorem dl_th_3 {œÉ : Nat} { p q : Formula œÉ } { Œ± Œ≤ : Action œÉ } { Œì : Context œÉ } : 
  (Œì ‚ä¢‚Çí‚Çõ‚Çõ (p ‚ü∂ ([Œ±]([Œ≤]q)))) ‚Üí 
  (Œì ‚ä¢‚Çí‚Çõ‚Çõ (p ‚ü∂ ([Œ± ; Œ≤]q))) := by 
  admit 

@[simp]
theorem edl_th_1 {œÉ : Nat} { p q : Formula œÉ } { Œ± Œ≤ : Action œÉ } {a : Agent} { Œì : Context œÉ } : 
  (Œì ‚ä¢‚Çí‚Çõ‚Çõ (p ‚ü∂ ([Œ±][Œ≤] (ùîπ a, q)))) ‚Üí 
  (Œì ‚ä¢‚Çí‚Çõ‚Çõ (p ‚ü∂ ([Œ±][Œ≤] (ùïÇ a, q)))) := by 
  intros h
  unfold 
  admit 
  have htriv : Œì ‚ä¢‚Çí‚Çõ‚Çõ (p ‚ü∂ [Œ±][Œ≤]q) :=
    let h‚ÇÅ : Œì ‚ä¢‚Çí‚Çõ‚Çõ ((ùîπ a, q) ‚ü∂ q) := OSSProof.base (Proof.ax (List.Mem.head _))
    let h‚ÇÇ := OSSProof.base (Proof.NECŒ± (Proof.NECŒ± h‚ÇÅ))
    pl_transitivity h h‚ÇÇ
  exact htriv


theorem oss { œÉ : Nat } { Œì : Context œÉ } { i r e : Agent } { n·µ¢ : Message œÉ } : 
  Œì ‚ä¢‚Çí‚Çõ‚Çõ ((‚ü® Œπ ((i ‚ñ∑ n·µ¢) ‚äî (@Œ≥·µ¢‚Çô·µ¢‚Çú œÉ i r)) ‚ü©) 
    ‚ü∂ ([(send i, r(‚¶É| ag(i) ‚Äñ n·µ¢ |‚¶Ñpk(r))) ; (recv r(‚¶É| ag(i) ‚Äñ n·µ¢ |‚¶Ñpk(r)))](ùïÇ r, ‚ü® ùïè i, n·µ¢ ‚ü©))) :=  by 
  have S‚ÇÅ : Œì ‚ä¢‚Çí‚Çõ‚Çõ ‚ü® Œπ ((i ‚ñ∑ n·µ¢) ‚äî (@Œ≥·µ¢‚Çô·µ¢‚Çú œÉ i r)) ‚ü© ‚ü∂ [send i,r(‚¶É| ag(i) ‚Äñ  n·µ¢ |‚¶Ñpk(r))]ùîπ i, ‚ü® ùïè r, n·µ¢ ‚ü© 
    := OSSProof.S‚ÇÅ 
  have H‚ÇÅ : Œì ‚ä¢‚Çí‚Çõ‚Çõ ‚ü® Œπ ((i ‚ñ∑ n·µ¢) ‚äî (@Œ≥·µ¢‚Çô·µ¢‚Çú œÉ i r)) ‚ü© ‚ü∂ [send i,r(‚¶É| ag(i) ‚Äñ  n·µ¢ |‚¶Ñpk(r))]‚ü® Œπ ((e ‚ñ∑ n·µ¢) ‚äî ((i ‚ñ∑ n·µ¢) ‚äî (@Œ≥·µ¢‚Çô·µ¢‚Çú œÉ i r))) ‚ü© 
    := OSSProof.base $ ProtocolProof.H‚ÇÅ 
  have hl‚ÇÄ :  Œì ‚ä¢‚Çí‚Çõ‚Çõ ‚ü® Œπ ((i ‚ñ∑ n·µ¢) ‚äî (@Œ≥·µ¢‚Çô·µ¢‚Çú œÉ i r)) ‚ü© ‚ü∂ [send i,r(‚¶É| ag(i) ‚Äñ  n·µ¢ |‚¶Ñpk(r))]((ùîπ i, ‚ü® ùïè r, n·µ¢ ‚ü©) ‚ãÄ (‚ü® Œπ ((e ‚ñ∑ n·µ¢) ‚äî ((i ‚ñ∑ n·µ¢) ‚äî (@Œ≥·µ¢‚Çô·µ¢‚Çú œÉ i r))) ‚ü© ))
    := dl_th_1 S‚ÇÅ H‚ÇÅ 
  have Œ≥‚ÇÅ : State œÉ := ((i ‚ñ∑ n·µ¢) ‚äî (@Œ≥·µ¢‚Çô·µ¢‚Çú œÉ i r))
  have H‚ÇÇ : Œì ‚ä¢‚Çí‚Çõ‚Çõ ‚ü® Œπ ((e ‚ñ∑ n·µ¢) ‚äî ((i ‚ñ∑ n·µ¢) ‚äî (@Œ≥·µ¢‚Çô·µ¢‚Çú œÉ i r))) ‚ü© ‚ü∂ [recv r(‚¶É| ag(i) ‚Äñ n·µ¢ |‚¶Ñpk(r))]‚ü® Œπ ((r ‚ñ∑ n·µ¢) ‚äî ((e ‚ñ∑ n·µ¢) ‚äî ((i ‚ñ∑ n·µ¢) ‚äî (@Œ≥·µ¢‚Çô·µ¢‚Çú œÉ i r)))) ‚ü© 
    := OSSProof.base $ ProtocolProof.H‚ÇÇ 
  have S‚ÇÇ : Œì ‚ä¢‚Çí‚Çõ‚Çõ ‚ü® Œπ ((e ‚ñ∑ n·µ¢) ‚äî ((i ‚ñ∑ n·µ¢) ‚äî (@Œ≥·µ¢‚Çô·µ¢‚Çú œÉ i r))) ‚ü© ‚ü∂ [recv r(‚¶É| ag(i) ‚Äñ n·µ¢ |‚¶Ñpk(r))](ùîπ r, ‚ü® ùïè i, n·µ¢ ‚ü©) 
    := OSSProof.S‚ÇÇ 
  have hl‚ÇÅ : Œì ‚ä¢‚Çí‚Çõ‚Çõ ‚ü® Œπ ((e ‚ñ∑ n·µ¢) ‚äî ((i ‚ñ∑ n·µ¢) ‚äî (@Œ≥·µ¢‚Çô·µ¢‚Çú œÉ i r))) ‚ü© ‚ü∂ [recv r(‚¶É| ag(i) ‚Äñ n·µ¢ |‚¶Ñpk(r))]((‚ü® Œπ ((r ‚ñ∑ n·µ¢) ‚äî ((e ‚ñ∑ n·µ¢) ‚äî ((i ‚ñ∑ n·µ¢) ‚äî (@Œ≥·µ¢‚Çô·µ¢‚Çú œÉ i r))))‚ü©) ‚ãÄ (ùîπ r, ‚ü® ùïè i, n·µ¢ ‚ü©))
    := dl_th_1 H‚ÇÇ S‚ÇÇ 
  have hl‚ÇÇ_K : Œì ‚ä¢‚Çí‚Çõ‚Çõ [send i,r(‚¶É| ag(i) ‚Äñ  n·µ¢ |‚¶Ñpk(r))] (‚ü® Œπ ((e ‚ñ∑ n·µ¢) ‚äî ((i ‚ñ∑ n·µ¢) ‚äî (@Œ≥·µ¢‚Çô·µ¢‚Çú œÉ i r))) ‚ü© ‚ü∂ [recv r(‚¶É| ag(i) ‚Äñ n·µ¢ |‚¶Ñpk(r))]((‚ü® Œπ ((r ‚ñ∑ n·µ¢) ‚äî ((e ‚ñ∑ n·µ¢) ‚äî ((i ‚ñ∑ n·µ¢) ‚äî (@Œ≥·µ¢‚Çô·µ¢‚Çú œÉ i r))))‚ü©) ‚ãÄ (ùîπ r, ‚ü® ùïè i, n·µ¢ ‚ü©)))
    := OSSProof.NECŒ± hl‚ÇÅ
  have hl‚ÇÉ : Œì ‚ä¢‚Çí‚Çõ‚Çõ ([send i,r(‚¶É| ag(i) ‚Äñ  n·µ¢ |‚¶Ñpk(r))](‚ü® Œπ ((e ‚ñ∑ n·µ¢) ‚äî ((i ‚ñ∑ n·µ¢) ‚äî (@Œ≥·µ¢‚Çô·µ¢‚Çú œÉ i r))) ‚ü©)) ‚ü∂ ([send i,r(‚¶É| ag(i) ‚Äñ  n·µ¢ |‚¶Ñpk(r))]( [recv r(‚¶É| ag(i) ‚Äñ n·µ¢ |‚¶Ñpk(r))]((‚ü® Œπ ((r ‚ñ∑ n·µ¢) ‚äî ((e ‚ñ∑ n·µ¢) ‚äî ((i ‚ñ∑ n·µ¢) ‚äî (@Œ≥·µ¢‚Çô·µ¢‚Çú œÉ i r))))‚ü©) ‚ãÄ (ùîπ r, ‚ü® ùïè i, n·µ¢ ‚ü©)))) 
    := OSSProof.MP (OSSProof.base (ProtocolProof.base Proof.KŒ±)) hl‚ÇÇ_K 
  have hl‚ÇÑ : Œì ‚ä¢‚Çí‚Çõ‚Çõ  ‚ü® Œπ ((i ‚ñ∑ n·µ¢) ‚äî (@Œ≥·µ¢‚Çô·µ¢‚Çú œÉ i r)) ‚ü© ‚ü∂ ([send i,r(‚¶É| ag(i) ‚Äñ  n·µ¢ |‚¶Ñpk(r))]( [recv r(‚¶É| ag(i) ‚Äñ n·µ¢ |‚¶Ñpk(r))]((‚ü® Œπ ((r ‚ñ∑ n·µ¢) ‚äî ((e ‚ñ∑ n·µ¢) ‚äî ((i ‚ñ∑ n·µ¢) ‚äî (@Œ≥·µ¢‚Çô·µ¢‚Çú œÉ i r))))‚ü©) ‚ãÄ (ùîπ r, ‚ü® ùïè i, n·µ¢ ‚ü©)))) 
    := pl_transitivity H‚ÇÅ hl‚ÇÉ 
  have st‚ÇÉ : Œì ‚ä¢‚Çí‚Çõ‚Çõ (‚ü®Œπ ((r ‚ñ∑ n·µ¢) ‚äî ((e ‚ñ∑ n·µ¢) ‚äî ((i ‚ñ∑ n·µ¢) ‚äî (@Œ≥·µ¢‚Çô·µ¢‚Çú œÉ i r))))‚ü©) ‚ü∂ (‚ü®ùïè r, n·µ¢‚ü©) 
    := OSSProof.base (ProtocolProof.base Proof.St‚ÇÉ') 
  have hl‚ÇÖ : Œì ‚ä¢‚Çí‚Çõ‚Çõ  ‚ü® Œπ ((i ‚ñ∑ n·µ¢) ‚äî (@Œ≥·µ¢‚Çô·µ¢‚Çú œÉ i r)) ‚ü© ‚ü∂ ([send i,r(‚¶É| ag(i) ‚Äñ  n·µ¢ |‚¶Ñpk(r))]( [recv r(‚¶É| ag(i) ‚Äñ n·µ¢ |‚¶Ñpk(r))]((ùîπ r, ‚ü® ùïè i, n·µ¢ ‚ü©))))  
    := dl_th_2 hl‚ÇÑ 
  have hl‚ÇÜ : Œì ‚ä¢‚Çí‚Çõ‚Çõ  ‚ü® Œπ ((i ‚ñ∑ n·µ¢) ‚äî (@Œ≥·µ¢‚Çô·µ¢‚Çú œÉ i r)) ‚ü© ‚ü∂ ([send i,r(‚¶É| ag(i) ‚Äñ  n·µ¢ |‚¶Ñpk(r))]( [recv r(‚¶É| ag(i) ‚Äñ n·µ¢ |‚¶Ñpk(r))]((ùïÇ r, ‚ü® ùïè i, n·µ¢ ‚ü©))))  
    := edl_th_1 hl‚ÇÖ 
  have hl‚Çá : Œì ‚ä¢‚Çí‚Çõ‚Çõ  ‚ü® Œπ ((i ‚ñ∑ n·µ¢) ‚äî (@Œ≥·µ¢‚Çô·µ¢‚Çú œÉ i r )) ‚ü© ‚ü∂ ([send i,r(‚¶É| ag(i) ‚Äñ  n·µ¢ |‚¶Ñpk(r)) ; recv r(‚¶É| ag(i) ‚Äñ n·µ¢ |‚¶Ñpk(r))]((ùïÇ r, ‚ü® ùïè i, n·µ¢ ‚ü©))) 
    := dl_th_3 hl‚ÇÜ 
  exact hl‚Çá 

/-
  **AUTOMATED GENERATED MODEL**
-/

/-
  **Generate model**
-/

namespace hidden 
def State (œÉ : Nat) := List (List $ Message œÉ)

def EmptyMessage (œÉ : Nat) : Message œÉ := Message.empty
def EmptyState {œÉ : Nat} : State œÉ := [[]]

structure AutomaticallyGeneratedModel (œÉ : Nat) where
  Agents : List Agent
  States : List $ State œÉ
  RùïÇ : List $ (Agent √ó List Nat)
  Rùîπ : List $ (Agent √ó List Nat)
  RPDLSend : List $ (Agent √ó Agent √ó Message œÉ √ó List Nat)
  RPDLRecv : List $ (Agent √ó Message œÉ √ó List Nat)
  RPDLGen : List $ (Agent √ó Message œÉ √ó List Nat)

def List.getAtIndex {Œ± : Type} (list : List Œ±) (i : Nat) : Option Œ± :=
  match i with
  | 0 => list.head?
  | i' + 1 => List.getAtIndex (list.tail!) i'

def List.getAtIndex! {Œ± : Type} (list : List Œ±) (i : Nat) (default : Œ±) : Œ± :=
  match List.getAtIndex list i with
  | none => default
  | some result => result

def MessageContext (œÉ : Nat) := List $ Message œÉ

def DeductionClosureStep {œÉ : Nat} (Œì : MessageContext œÉ) (Œìc : MessageContext œÉ) : MessageContext œÉ :=
  match Œì with 
  | [] => [] 
  | (m :: tail) => match m with 
    | ‚¶É|m'|‚¶Ñk => if Œìc.contains k && !Œìc.contains m' then m' :: m :: DeductionClosureStep tail Œìc else m :: DeductionClosureStep tail Œìc
    | m‚ÇÅ ‚Äñ m‚ÇÇ => 
    if Œìc.contains (m‚ÇÅ ‚Äñ m‚ÇÇ) then 
      if Œìc.contains m‚ÇÅ then 
        if Œìc.contains m‚ÇÇ then 
          m :: DeductionClosureStep tail Œìc 
        else 
          m :: m‚ÇÇ :: DeductionClosureStep tail Œìc 
      else 
        if Œìc.contains m‚ÇÇ then 
          m :: m‚ÇÅ :: DeductionClosureStep tail Œìc 
        else 
          m :: m‚ÇÅ :: m‚ÇÇ :: DeductionClosureStep tail Œìc 
    else m :: DeductionClosureStep tail Œìc 
    | _ => m :: DeductionClosureStep tail Œìc

set_option maxHeartbeats 800000

def DeductionClosure {œÉ : Nat} (Œì : MessageContext œÉ) : MessageContext œÉ := 
  let Œì‚ÇÄ := DeductionClosureStep Œì Œì
  let Œì‚ÇÅ := DeductionClosureStep Œì‚ÇÄ Œì‚ÇÄ 
  let Œì‚ÇÇ := DeductionClosureStep Œì‚ÇÅ Œì‚ÇÅ 
  Œì‚ÇÇ 


def MessageInfer {œÉ : Nat} (Œì : MessageContext œÉ) (m : Message œÉ) : Bool := 
  let Œì' := DeductionClosure Œì
  match m with 
  | Message.empty => True
  | m‚ÇÅ ‚Äñ m‚ÇÇ => Œì'.contains (m‚ÇÅ ‚Äñ m‚ÇÇ) || (Œì'.contains m‚ÇÅ && Œì'.contains m‚ÇÇ) 
  | ‚¶É|m‚ÇÅ|‚¶Ñm‚ÇÇ => Œì'.contains (‚¶É|m‚ÇÅ|‚¶Ñm‚ÇÇ) || (Œì'.contains m‚ÇÅ && Œì'.contains m‚ÇÇ)
  | sk(i) => Œì'.contains $ sk(i)
  | pk(i) => Œì'.contains $ pk(i)
  | ag(i) => Œì'.contains $ ag(i)
  | text(t) => Œì'.contains $ text(t)
  | Message.symmetricKey i j k => Œì'.contains $ Message.symmetricKey i j k 

notation Œì " ‚ä¢Œº " m => MessageInfer Œì m 

def AwarenessSatisfies {œÉ : Nat} (M : AutomaticallyGeneratedModel œÉ) (wIndex : Nat) (agent : Agent) (m : Message œÉ) : Bool := 
  let modelAgents : List Agent := M.Agents
  let numberOfAgents : Nat := modelAgents.length
  let zippedAgentList := List.zip modelAgents $ List.range numberOfAgents
  let agentStatePosition : Nat := List.getAtIndex! (List.map (fun (_, pos) => pos) (List.filter  (fun (ag, _) => ag == agent) zippedAgentList) ) 0 0
  let currentState : State œÉ := List.getAtIndex! M.States wIndex EmptyState 
  let currentAgentState := List.getAtIndex! currentState agentStatePosition []
  currentAgentState ‚ä¢Œº m 

def ModalKBStates {œÉ : Nat} (_ : AutomaticallyGeneratedModel œÉ) (wIndex : Nat) (agent : Agent) (relation : List $ (Agent √ó List Nat)) : List Nat :=
  let agentRelation : List $ List Nat := ((relation.filter (fun (ag, _) => ag == agent)).map (fun (_, y) => y)).filter (fun list => List.getAtIndex! list 0 0 == wIndex)
  let accessibleStates : List Nat := agentRelation.map (fun list => List.getAtIndex! list 1 0)
  accessibleStates 


def PDLSendStates {œÉ : Nat} (_ : AutomaticallyGeneratedModel œÉ) (wIndex : Nat) (i : Agent) (j : Agent) (m : Message œÉ) (relation : List $ (Agent √ó Agent √ó Message œÉ √ó List Nat)) : List Nat := 
  let agentRelation : List $ List Nat := ((relation.filter (fun (agi, agj, msg, _) => agi == i && agj == j && msg == m)).map (fun (_, _, _, y) => y)).filter (fun list => List.getAtIndex! list 0 0 == wIndex)
  let accessibleStates : List Nat := agentRelation.map (fun list => List.getAtIndex! list 1 0)
  accessibleStates 

def PDLRecvStates {œÉ : Nat} (_ : AutomaticallyGeneratedModel œÉ) (wIndex : Nat) (j : Agent) (m : Message œÉ) (relation : List $ (Agent √ó Message œÉ √ó List Nat)) : List Nat :=
  let agentRelation : List $ List Nat := ((relation.filter (fun (agj, msg, _) => agj == j && msg == m)).map (fun (_, _, y) => y)).filter (fun list => List.getAtIndex! list 0 0 == wIndex)
  let accessibleStates : List Nat := agentRelation.map (fun list => List.getAtIndex! list 1 0)
  accessibleStates 

def PDLGenStates {œÉ : Nat} (_ : AutomaticallyGeneratedModel œÉ) (wIndex : Nat) (j : Agent) (m : Message œÉ) (relation : List $ (Agent √ó Message œÉ √ó List Nat)) : List Nat :=
  let agentRelation : List $ List Nat := ((relation.filter (fun (agj, msg, _) => agj == j && msg == m)).map (fun (_, _, y) => y)).filter (fun list => List.getAtIndex! list 0 0 == wIndex)
  let accessibleStates : List Nat := agentRelation.map (fun list => List.getAtIndex! list 1 0)
  accessibleStates 

def SatisfiesAtState {œÉ : Nat} (M : AutomaticallyGeneratedModel œÉ) (œÜ : Formula œÉ) (wIndex : Nat) : Bool :=
  match œÜ with
  | Formula.atom _ => True 
  | Formula.true => True 
  | œÜ ‚ü∂ œà => (SatisfiesAtState M œÜ wIndex) ‚Üí (SatisfiesAtState M œà wIndex)
  | ~œÜ => !(SatisfiesAtState M œÜ wIndex) 
  | ùïè agent, m => AwarenessSatisfies M wIndex agent m  
  | ùîπ agent, œÜ => 
    let accessibleStates := ModalKBStates M wIndex agent M.Rùîπ
    let applySatisfaction := accessibleStates.map (fun accessibleState => SatisfiesAtState M œÜ accessibleState)
    applySatisfaction.foldr (fun x y => x && y) True 
  | [send i, j(m)] œÜ => 
    let accessibleStates := PDLSendStates M wIndex i j m M.RPDLSend
    let applySatisfaction := accessibleStates.map (fun accessibleState => SatisfiesAtState M œÜ accessibleState)
    applySatisfaction.foldr (fun x y => x && y) True 
  | [recv j(m)] œÜ => 
    let accessibleStates := PDLRecvStates M wIndex j m M.RPDLRecv 
    let applySatisfaction := accessibleStates.map (fun accessibleState => SatisfiesAtState M œÜ accessibleState)
    applySatisfaction.foldr (fun x y => x && y) True 
  | _ => True 

notation M " at " w " ‚äß " œÜ => SatisfiesAtState M œÜ w

def Satisfies {œÉ : Nat} (M : AutomaticallyGeneratedModel œÉ) (œÜ : Formula œÉ) : Bool := 
  let allStates := List.range $ M.States.length 
  let satisfiesAllStates := allStates.map (fun state => M at state ‚äß œÜ)
  satisfiesAllStates.foldr (fun x y => x && y) True 

notation M " ‚äß " œÜ => Satisfies M œÜ 


structure ProtocolAction (œÉ : Nat) where 
  Sender: Agent
  Receiver: Agent
  Message: Message œÉ 

instance EmptyProtocolAction {œÉ : Nat} : ProtocolAction œÉ := 
{
  Sender := "",
  Receiver := "",
  Message := Message.empty 
}  

structure Protocol (œÉ : Nat) where
  Agents : List Agent 
  SymmetricKeys : List $ (Agent √ó Agent √ó Message œÉ)
  Specification : List $ ProtocolAction œÉ 

def GetAllSubMessages {œÉ : Nat} (m : Message œÉ) : List $ Message œÉ := 
  match m with 
  | Message.empty => [] 
  | text(t) => [text(t) ]
  | ag(i) => [ag(i) ]
  | Message.symmetricKey k i j => [Message.symmetricKey k i j]
  | pk(i) => [pk(i) ]
  | sk(i) => [sk(i) ]
  | ‚¶É|m|‚¶Ñk => GetAllSubMessages m ++ [k] 
  | m‚ÇÅ ‚Äñ m‚ÇÇ => GetAllSubMessages m‚ÇÅ ++ GetAllSubMessages m‚ÇÇ   

def GetAllMessagesFromList {œÉ : Nat} (list : List $ Message œÉ) : List $ Message œÉ := 
  match list with 
  | [] => [] 
  | (message :: tail) => 
    match message with 
    | Message.empty => tail 
    | text(t) => text(t) :: tail 
    | ag(i) => ag(i) :: tail 
    | Message.symmetricKey k i j => (Message.symmetricKey k i j) :: tail 
    | pk(i) => pk(i) :: tail 
    | sk(i) => sk(i) :: tail 
    | ‚¶É|m|‚¶Ñk => GetAllSubMessages (‚¶É|m|‚¶Ñk) ++ [‚¶É|m|‚¶Ñk] ++ tail 
    | m‚ÇÅ ‚Äñ m‚ÇÇ => GetAllSubMessages (m‚ÇÅ ‚Äñ m‚ÇÇ) ++ [m‚ÇÅ ‚Äñ m‚ÇÇ] ++ tail 

def List.removeDuplicates {Œ± : Type} [BEq Œ±] (list : List Œ±) : List Œ± := 
  match list with 
  | [] => []
  | (head :: tail) => if tail.contains head then tail else head :: tail 


def AppendAgentNewKnowledge {œÉ : Nat} (P : Protocol œÉ) (agent : Agent) (currentState : State œÉ) (newKnowledge : List $ Message œÉ) : State œÉ := 
  let agentsNumber := P.Agents.length 
  let agentsPositions := List.zip P.Agents $ List.range $ agentsNumber
  let agentPosition := List.getAtIndex! (List.map (fun (_, pos) => pos) (List.filter (fun (ag, _) => ag == agent) agentsPositions)) 0 0
  let stateForAgents := currentState.zip $ List.range $ agentsNumber 
  let newState := stateForAgents.map (fun (ik, pos) => 
    if pos == agentPosition then List.removeDuplicates (List.append ik newKnowledge) else ik 
  )
  newState

def BuildFromActions {œÉ : Nat} (P : Protocol œÉ) (currentStateIndex : Nat) (states : List $ State œÉ) (statesLeft : Nat)
  : (List $ State œÉ) 
  √ó (List $ (Agent √ó Agent √ó Message œÉ √ó List Nat)) 
  √ó (List $ (Agent √ó Message œÉ √ó List Nat)) := 
  match statesLeft with 
  | 0 => ([], [], [])
  | n + 1 => 
    let currentAction := List.getAtIndex! P.Specification currentStateIndex ({ Sender := "", Receiver := "", Message := Message.empty })
    let sender := currentAction.Sender 
    let receiver := currentAction.Receiver 
    let message := currentAction.Message 
    let lastState := List.getAtIndex! states (states.length - 1) EmptyState 
    let newState := AppendAgentNewKnowledge P sender lastState [message] 
  
    let newUpdatedState := 
      if currentStateIndex != 0 then 
        let lastAction := List.getAtIndex! P.Specification (currentStateIndex - 1) ({ Sender := "", Receiver := "", Message := Message.empty })
        let lastReceiver := lastAction.Receiver 
        let lastMessage := lastAction.Message 
        AppendAgentNewKnowledge P lastReceiver newState [lastMessage]
      else newState 

    (newUpdatedState :: (BuildFromActions P (currentStateIndex + 1) (states.append [newUpdatedState]) n).fst, 
    if message != Message.empty then 
      ((sender, receiver, message, [currentStateIndex, currentStateIndex + 1]) :: (BuildFromActions P (currentStateIndex + 1) (states.append [newUpdatedState]) n).snd.fst) 
    else (BuildFromActions P (currentStateIndex + 1) (states.append [newUpdatedState]) n).snd.fst,
    if message != Message.empty then 
      ((receiver, message, [currentStateIndex, currentStateIndex + 1]) :: (BuildFromActions P (currentStateIndex + 1) (states.append [newUpdatedState]) n).snd.snd) 
    else (BuildFromActions P (currentStateIndex + 1) (states.append [newUpdatedState]) n).snd.snd
    )

def BuildModel {œÉ : Nat} (P : Protocol œÉ) : AutomaticallyGeneratedModel œÉ := 
  let specification := P.Specification 
  let agentsNumber := P.Agents.length 
  let agentsPositions := List.zip P.Agents $ List.range $ agentsNumber

  let initialAction := specification.getAtIndex! 0 EmptyProtocolAction
  let agentsInitialKnowledgeEmpty : List $ List $ Message œÉ := List.replicate agentsNumber [] 
  let initialAgentPosition := ((agentsPositions.filter (fun (ag, _) => ag == initialAction.Sender)).map (fun (_, pos) => pos)).getAtIndex! 0 0

  let agentsInitialKnowledge := ((agentsInitialKnowledgeEmpty.zip (List.range agentsNumber)).map (fun (ik, agentPos) => 
    if agentPos == initialAgentPosition then ik.append [initialAction.Message] else ik.append []))

  let agentsInitialKnowledgeKeys := (agentsInitialKnowledge.zip (List.range agentsNumber)).map (fun (ik, pos) => 
    let agentByPos := ((agentsPositions.filter (fun ((_ : Agent), y) => y == pos)).map (fun ((x : Agent), (_ : Nat)) => x)).getAtIndex! 0 ""
    let searchInSymmetricKeys := P.SymmetricKeys.filter (fun ((x : Agent), (y : Agent), (_ : Message œÉ)) => x == agentByPos || y == agentByPos)
    let key := if searchInSymmetricKeys.length > 0 then (searchInSymmetricKeys.getAtIndex! 0 (("", "", Message.empty) : Agent √ó Agent √ó Message œÉ)).snd.snd else Message.empty 
    let otherAgentsPublicKeys : List $ Message œÉ := (P.Agents.filter (fun ag => ag != agentByPos)).map (fun ag => pk(ag))
    if key != Message.empty then (ik.append [key, sk(agentByPos), pk(agentByPos) ]).append otherAgentsPublicKeys else (ik.append [sk(agentByPos), pk(agentByPos) ]).append otherAgentsPublicKeys
    )
  
  let initialState : State œÉ := agentsInitialKnowledgeKeys

  let result := BuildFromActions P 0 [initialState] (specification.length + 1)

  let states := result.fst 
  let pdlRelationSend := result.snd.fst 

  let firstOccuranceForEveryAgent := P.Agents.map (fun agent => 
    let firstState : Nat := (((pdlRelationSend.filter (fun (ag, _, _, _) => ag == agent)).map (fun (_, _, _, ls) => ls)).getAtIndex! 0 []).getAtIndex! 0 0 
    (agent, firstState)
  )

  let numberOfStates := states.length 

  let knowledge_relation := firstOccuranceForEveryAgent.map (fun (ag, initialAgentState) => 
    let allStates := List.range numberOfStates 
    let agentStates := (List.foldr (fun x y => x ++ y) [] $ (allStates.map (fun x => allStates.map (fun y => if x <= y then [x, y] else []))))
    let agentListFiltered := agentStates.filter (fun (list : List Nat) => list.getAtIndex! 0 0 >= initialAgentState) 
    (agentListFiltered.map (fun list => (ag, list))).filter (fun (_, list) => list != [])
  )

  let knowledge := List.foldr (fun x y => x ++ y) [] knowledge_relation 

  let belief_relation := firstOccuranceForEveryAgent.map (fun (ag, initialAgentState) => 
    let allStates := List.range numberOfStates 
    let agentStates := (List.foldr (fun x y => x ++ y) [] $ (allStates.map (fun x => allStates.map (fun y => if x < y then [x, y] else [])))) ++ [[allStates.getAtIndex! (allStates.length - 1) 0, allStates.getAtIndex! (allStates.length - 1) 0]]
    let agentListFiltered := agentStates.filter (fun (list : List Nat) => list.getAtIndex! 0 0 >= initialAgentState) 
    (agentListFiltered.map (fun list => (ag, list))).filter (fun (_, list) => list != []))

  let belief := List.foldr (fun x y => x ++ y) [] belief_relation 

  {
    Agents := P.Agents,
    States := states,
    RùïÇ := knowledge,
    Rùîπ := belief,
    RPDLSend := pdlRelationSend,
    RPDLRecv := result.snd.snd,
    RPDLGen := [],
  }

/-
  **OSS**
-/

section OSS
  instance OSS {œÉ : Nat} : Protocol œÉ := 
  {
    Agents := ["i", "r"]
    SymmetricKeys := []
    Specification := [
      { Sender := "i", Receiver := "r", Message := ‚¶É|#"i"# ‚Äñ #"ni"#|‚¶Ñpk("r") }
    ]
  }

  def OSSModel {œÉ : Nat} : AutomaticallyGeneratedModel œÉ := BuildModel OSS

  #reduce OSSModel 

  #reduce OSSModel ‚äß ùïè "i", #"ni"#

  #reduce OSSModel ‚äß [recv "r"(‚¶É|#"i"# ‚Äñ #"ni"#|‚¶Ñpk("r"))] (ùïè "r", (‚¶É|#"i"# ‚Äñ #"ni"#|‚¶Ñpk("r")))

  #reduce OSSModel ‚äß [recv "r"(‚¶É|#"i"# ‚Äñ #"ni"#|‚¶Ñpk("r"))] ((ùïÇ "i", ùïè "r", #"ni"#) ‚ãÄ (ùïÇ "r", ùïè "i", #"ni"#))

  

end OSS

section OSSE
  instance OSSE {œÉ : Nat} : Protocol œÉ := 
  {
    Agents := ["i", "r", "e"]
    SymmetricKeys := []
    Specification := [
      { Sender := "e", Receiver := "r", Message := ‚¶É|#"i"# ‚Äñ #"ne"#|‚¶Ñpk("r") }
    ]
  }

  def OSSEModel {œÉ : Nat} : AutomaticallyGeneratedModel œÉ := BuildModel OSSE

  #reduce OSSEModel 

  #reduce OSSEModel ‚äß [recv "r"(‚¶É|#"i"# ‚Äñ #"ni"#|‚¶Ñpk("r"))] ((ùïÇ "i", ùïè "r", #"ni"#) ‚ãÄ (ùïÇ "r", ùïè "i", #"ni"#))

end OSSE

/-
  **Needham Schroeder**
-/

section NeedhamSchroeder
  instance NeedhamSchroeder {œÉ : Nat} : Protocol œÉ := 
  {
    Agents := ["i", "r"]
    SymmetricKeys := [] 
    Specification := [
      { Sender := "i", Receiver := "r", Message := ‚¶É|ag("i") ‚Äñ #"ni"#|‚¶Ñpk("r") },
      { Sender := "r", Receiver := "r", Message := ‚¶É|#"ni"# ‚Äñ #"nr"# |‚¶Ñpk("i") },
      { Sender := "i", Receiver := "r", Message := ‚¶É|#"nr"#|‚¶Ñpk("r") }
    ]
  }

  def NeedhamSchroederModel {œÉ : Nat} : AutomaticallyGeneratedModel œÉ := BuildModel NeedhamSchroeder

  #reduce NeedhamSchroederModel

  #reduce NeedhamSchroederModel ‚äß [recv "r"(‚¶É|ag("i") ‚Äñ #"ni"#|‚¶Ñpk("r"))] ((ùïÇ "r", ùïè "i", #"ni"#) ‚ãÄ (ùïÇ "i", ùïè "r", #"ni"#))
  -- true

  -- #reduce NeedhamSchroederModel ‚äß [recv "r"(‚¶É|ag("i") ‚Äñ #"ni"#|‚¶Ñpk("r"))] ([recv "i"(‚¶É|#"ni"# ‚Äñ #"nr"# |‚¶Ñpk("i"))] ùïÇ "i", ùïè "r", #"nr"#)
  -- true 

end NeedhamSchroeder

section NeedhamSchroederMitM
  instance NeedhamSchroederMitM {œÉ : Nat} : Protocol œÉ := 
  {
    Agents := ["i", "r", "e"]
    SymmetricKeys := [] 
    Specification := [
      { Sender := "i", Receiver := "e", Message := ‚¶É|ag("i") ‚Äñ #"ni"#|‚¶Ñpk("e") },
      { Sender := "e", Receiver := "r", Message := ‚¶É|ag("i") ‚Äñ #"ni"#|‚¶Ñpk("r") },
      { Sender := "r", Receiver := "e", Message := ‚¶É|#"ni"# ‚Äñ #"nr"# |‚¶Ñpk("e") },
      { Sender := "e", Receiver := "i", Message := ‚¶É|#"ni"# ‚Äñ #"nr"# |‚¶Ñpk("i") },
      { Sender := "i", Receiver := "e", Message := ‚¶É|#"nr"#|‚¶Ñpk("e") },
      { Sender := "e", Receiver := "r", Message := ‚¶É|#"nr"#|‚¶Ñpk("r") }
    ]
  }

  def NeedhamSchroederMitMModel {œÉ : Nat} : AutomaticallyGeneratedModel œÉ := BuildModel NeedhamSchroederMitM

  #reduce NeedhamSchroederMitMModel

  -- #reduce NeedhamSchroederMitMModel ‚äß [recv "r"(‚¶É|ag("i") ‚Äñ #"ni"#|‚¶Ñpk("r"))] ùïÇ "r", ùïè "i", #"ni"#
  -- true 

  -- #reduce NeedhamSchroederMitMModel ‚äß ùïÇ "i", ùïè "r", #"ni"#
  -- false 
end NeedhamSchroederMitM
end hidden 